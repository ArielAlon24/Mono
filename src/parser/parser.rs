use crate::models::error::Error;
use crate::models::error::InvalidSyntax;
use crate::parser::node::Node;
use crate::tokenizer::token::{Token, TokenKind};
use crate::Tokenizer;
use core::str::Chars;
use std::iter::Peekable;

/*
The atom macro takes a token and returns the token in a box
wrapped in Ok result.
*/
macro_rules! atom {
    ($token:expr) => {
        Ok(Box::new(Node::Atom($token)))
    };
}

/*
The unexpected_error macro takes a token and returns an
InvalidSyntax error of type UnexpectedToken using the given
token, wrapped in an Err result.
*/
macro_rules! unexpected_error {
    ($token:expr) => {
        Err(Error::invalid_syntax(InvalidSyntax::UnexpectedToken {
            token: $token,
        }))
    };
}

/*
The unclosed_error macro takes a start position, a found and
expected token regarding an unclosed delimiter error, it
generate an InvalidSyntax error of type
UnclosedTokenDelimiter using the three arguments, then wraps
the error in an Err result.
*/
macro_rules! unclosed_error {
    ($start:expr, $end:expr, $delimeter:expr) => {
        Err(Error::invalid_syntax(
            InvalidSyntax::UnclosedTokenDelimeter {
                start: $start,
                found: $end,
                delimiter: $delimeter,
            },
        ))
    };
}

// ParserItem is the return type of the parsing process
type ParserItem = Result<Box<Node>, Error>;

/*
--- Parser (struct) ---

The Parser struct is responsible for parsing the tokens
generated by the Tokenizer and transforming them into an AST.
It follows the grammar that can be founded in 'mono.gram'
*/
pub struct Parser<'a> {
    tokenizer: Tokenizer<Peekable<Chars<'a>>>,
}

impl<'a> Parser<'a> {
    /*
    The new function is the constructor for a Parser, it takes
    a tokenizer which can be seen as an iterator and returns a
    Parser struct.
    */
    pub fn new(tokenizer: Tokenizer<Peekable<Chars<'a>>>) -> Self {
        return Self {
            tokenizer: tokenizer,
        };
    }

    /*
    The parse method parses the tokenizer using Mono's grammar
    rules and returns the ParserItem type, meaning if every
    thing went correctly an AST but if an error encountered it
    returns that error.
    */
    pub fn parse(&mut self) -> ParserItem {
        let expr = self.parse_bool_expr()?;
        match self.tokenizer.peek() {
            None => Ok(expr),
            _ => Err(Error::invalid_syntax(InvalidSyntax::MultipleExpressions {
                position: self.tokenizer.get_position(),
            })),
        }
    }

    /*
    The parse_binary_op method takes an operators (TokenKind)
    array, and a left and right functions then it parses a Mono
    grammar rule of the fashion:
    <C> ::= <A>
        | <A> [operation_1 <B>] *
        | <A> [operation_2 <B>] *
        | <A> [operation_3 <B>] *
    Where left is the function creating ASTs of type 'A', right
    is the function creating ASTs of type 'B' and operators is
    [operation_1, operation_2, operation_3] and 'C' is the AST
    type that is returned.
    */
    fn parse_binary_op(
        &mut self,
        operators: &[TokenKind],
        left: fn(&mut Self) -> ParserItem,
        right: fn(&mut Self) -> ParserItem,
    ) -> ParserItem {
        let mut root = left(self)?;
        while let Some(Ok(token)) = self.tokenizer.peek() {
            if !operators.contains(&token.kind) {
                break;
            }
            root = Box::new(Node::BinaryOp(
                root,
                self.tokenizer.next().unwrap()?,
                right(self)?,
            ));
        }
        Ok(root)
    }

    /*
    The parse_unary_op method takes an operators (TokenKind)
    array, and a operand and default functions then in parse a
    Mono grammar rule of the fashion:
    <C> ::= <A>
        | operation_1 <B>
        | operation_2 <B>
    Where default is function creating ASTs of type 'A', operand
    is the function creating ASTs of type 'B', operators is the
    array [operation_1, operation_2] and 'C' is the returned AST
    type.
    */
    fn parse_unary_op(
        &mut self,
        operators: &[TokenKind],
        operand: fn(&mut Self) -> ParserItem,
        defualt: fn(&mut Self) -> ParserItem,
    ) -> ParserItem {
        match self.tokenizer.peek() {
            Some(Ok(token)) if operators.contains(&token.kind) => Ok(Box::new(Node::UnaryOp(
                self.tokenizer.next().unwrap()?,
                operand(self)?,
            ))),
            _ => defualt(self),
        }
    }

    /*
    The parse_atom method follows the atom grammar rules and
    parses accordingly an AST. It returns the parsed AST or in
    a case where an error is encountered the error gets returned
    */
    fn parse_atom(&mut self) -> ParserItem {
        if let None = self.tokenizer.peek() {
            return unexpected_error!(None);
        }

        let token = self.tokenizer.next().unwrap()?;
        match token.kind {
            TokenKind::LeftParen => {
                let bool_expr = self.parse_bool_expr()?;
                match self.tokenizer.next() {
                    Some(Ok(t)) if t.kind == TokenKind::RightParen => Ok(bool_expr),
                    Some(Ok(end)) => unclosed_error!(token, Some(end), TokenKind::RightParen),
                    _ => unclosed_error!(token, None, TokenKind::RightParen),
                }
            }
            TokenKind::Integer(_) | TokenKind::Float(_) => atom!(token),
            TokenKind::Boolean(_) => atom!(token),
            _ => unexpected_error!(Some(token)),
        }
    }

    /*
    The following functions are just specific cases of both
    'parse_binary_op' and 'parse_unary_op' functions. They are
    ordered in the same order as the grammar for readability and
    clarity as each one uses the functions that came before her.
    */

    fn parse_power(&mut self) -> ParserItem {
        self.parse_binary_op(&[TokenKind::Pow], Self::parse_atom, Self::parse_factor)
    }

    fn parse_factor(&mut self) -> ParserItem {
        self.parse_unary_op(
            &[TokenKind::Sub, TokenKind::Add],
            Self::parse_factor,
            Self::parse_power,
        )
    }

    fn parse_term(&mut self) -> ParserItem {
        self.parse_binary_op(
            &[TokenKind::Mul, TokenKind::Div, TokenKind::Mod],
            Self::parse_factor,
            Self::parse_factor,
        )
    }

    fn parse_expr(&mut self) -> ParserItem {
        self.parse_binary_op(
            &[TokenKind::Add, TokenKind::Sub],
            Self::parse_term,
            Self::parse_term,
        )
    }

    fn parse_comparison(&mut self) -> ParserItem {
        self.parse_binary_op(
            &Token::COMPERATORS.to_vec(),
            Self::parse_expr,
            Self::parse_expr,
        )
    }

    fn parse_bool_factor(&mut self) -> ParserItem {
        self.parse_unary_op(
            &[TokenKind::Not],
            Self::parse_bool_factor,
            Self::parse_comparison,
        )
    }

    fn parse_bool_term(&mut self) -> ParserItem {
        self.parse_binary_op(
            &[TokenKind::And],
            Self::parse_bool_factor,
            Self::parse_bool_factor,
        )
    }

    fn parse_bool_expr(&mut self) -> ParserItem {
        self.parse_binary_op(
            &[TokenKind::Or],
            Self::parse_bool_term,
            Self::parse_bool_term,
        )
    }
}
